<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <title>IP 获取演示 - WebRTC & API</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 2em auto;
      max-width: 700px;
      line-height: 1.7;
      color: #222;
      background: #fafbfc;
    }

    h1,
    h2 {
      color: #2b6cb0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1em;
    }

    th,
    td {
      padding: 8px 12px;
      border: 1px solid #ddd;
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
    }

    section {
      margin-bottom: 2em;
    }
  </style>
</head>

<body>
  <a href="/">返回</a>
  <h1>IP 获取演示</h1>
  <section>
    <h2>WebRTC 获取本地 IP</h2>
    <div id="webrtc-ip">加载中...</div>
  </section>
  <section>
    <h2>NAT 类型说明</h2>
    <ul>
      <li>
        <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#host" target="_blank">全锥形 NAT (Full Cone NAT)</a></strong>：
        所有外部主机都能通过映射的端口访问内部主机。
      </li>
      <li>
        <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#srflx" target="_blank">受限锥形 NAT (Restricted Cone NAT)</a></strong>：
        外部主机只有在发送过数据给内部主机后，才能访问内部主机的端口。
      </li>
      <li>
        <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#prflx" target="_blank">端口受限 NAT (Port Restricted NAT)</a></strong>：
        外部主机只有在发送过数据给内部主机指定端口后，才能访问该端口。
      </li>
      <li>
        <strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#relay" target="_blank">对称 NAT (Symmetric NAT)</a></strong>：
        不同外部地址映射不同端口，通常无法直接建立 P2P 连接，需要中继 (relay)。
      </li>
      <li>
        <strong>未知 NAT 类型</strong>：
        无法确定 NAT 类型。
      </li>
    </ul>
  </section>
  <section>
    <h2>API 获取 IP 信息</h2>
    <pre id="api-json">加载中...</pre>
  </section>

  <script>
    // https://gist.github.com/mondain/b0ec1cf5f60ae726202e
    // https://github.com/pradt2/always-online-stun/blob/master/valid_hosts.txt
    const stunServers = [
      { provider: 'Google', urls: 'stun:stun.l.google.com:19302' },
      { provider: 'Cloudflare', urls: 'stun:stun.cloudflare.com:3478' },
      { provider: 'XiaoMi', urls: 'stun:stun.miwifi.com:3478' },
      { provider: 'Bilibili', urls: 'stun:stun.chat.bilibili.com:3478' },
      { provider: 'Nextcloud', urls: 'stun:stun.nextcloud.com:3478' }
    ];

    async function getIpFromStun(serverConfig) {
      return new Promise((resolve) => {
        const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
        if (!RTCPeerConnection) {
          resolve({ provider: serverConfig.provider, ips: [] });
          return;
        }

        const ips = [];
        const pc = new RTCPeerConnection({ iceServers: serverConfig.urls ? [serverConfig] : [] });
        pc.createDataChannel('');
        pc.createOffer().then(offer => pc.setLocalDescription(offer));

        pc.onicecandidate = (event) => {
          if (!event || !event.candidate) {
            pc.close();
            resolve({
              provider: serverConfig.provider,
              ips: ips
            });
            return;
          }

          console.debug(event.candidate);
          const ip = (event.candidate.address || '').replace(/^\[|\]$/g, '');
          if (ip) {
            const natType = inferNatType(event.candidate.type);
            ips.push({ ip, natType });
          }
        };
      });
    }

    function inferNatType(candidateType) {
      // https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type
      const natTypes = {
        'host': '全锥形 NAT (Full Cone NAT)',
        'srflx': '受限锥形 NAT (Restricted Cone NAT)',
        'prflx': '端口受限 NAT (Port Restricted NAT)',
        'relay': '对称 NAT (Symmetric NAT)'
      };
      return natTypes[candidateType] || '未知 NAT 类型';
    }

    async function getAllStunIps() {
      const results = await Promise.all(stunServers.map(server => getIpFromStun(server)));
      return results;
    }

    getAllStunIps().then(results => {
      const table = document.createElement('table');
      const header = document.createElement('thead');
      header.innerHTML = `<tr>
                            <th>提供者</th>
                            <th>IP 地址</th>
                            <th>NAT 类型</th>
                          </tr>`;
      table.appendChild(header);

      const tbody = document.createElement('tbody');
      let lastProvider = '';
      let providerCount = 0;

      results.forEach(result => {
        if (result.ips.length === 0) {
          const row = document.createElement('tr');
          row.innerHTML = `<td rowspan="1">${result.provider}</td><td colspan="2">未获取到 IP</td>`;
          tbody.appendChild(row);
        } else {
          result.ips.forEach((entry, index) => {
            const row = document.createElement('tr');
            if (result.provider === lastProvider) {
              row.innerHTML = `<td>${entry.ip}</td><td>${entry.natType}</td>`;
            } else {
              providerCount = result.ips.length;
              row.innerHTML = `<td rowspan="${providerCount}">${result.provider}</td><td>${entry.ip}</td><td>${entry.natType}</td>`;
            }
            lastProvider = result.provider;
            tbody.appendChild(row);
          });
        }
      });

      table.appendChild(tbody);
      const webrtcIpDiv = document.getElementById('webrtc-ip');
      webrtcIpDiv.innerHTML = '';
      webrtcIpDiv.appendChild(table);
    });


    // API 获取 IP 信息
    fetch('/api?format=json')
      .then(r => r.json())
      .then(data => {
        document.getElementById('api-json').textContent = JSON.stringify(data, null, 2);
      })
      .catch(() => {
        document.getElementById('api-json').textContent = '获取失败';
      });
  </script>

</body>

</html>
