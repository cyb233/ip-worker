<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <meta charset="UTF-8">
  <title>IP 获取演示 - WebRTC & API</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="no-referrer">
  <meta name="robots" content="noimageindex">
  <script src="https://cdn.jsdelivr.net/gh/kirakiray/ofa.js/dist/ofa.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/kirakiray/ofa.js/libs/scsr/dist/scsr.min.js"></script>
  <script src="./js/public.js"></script>
  <link rel="stylesheet" href="./css/public.css" />
</head>

<body>
  <o-app src="./app-config.mjs">
    <template page>
      <link rel="stylesheet" href="./css/public.css" />
      <a href="/" olink>返回</a>
      <header>
        <h1>IP 获取演示 - WebRTC & API</h1>
        <p>本服务可获取访问者的 <b>IP</b> 及相关地理信息，支持多种格式返回。</p>
        <p>本页面展示了通过WebRTC功能获取到的IP，如果您安装了禁用WebRTC的插件，可以暂时关闭以查看结果</p>
      </header>
      <main>
        <h2>IP 获取演示</h2>
        <section>
          <h2>WebRTC 获取 IP</h2>
          <x-if :value="stunResults.length">
            <table style="border: 1px;" cellspacing="0" cellpadding="4">
              <thead>
                <tr>
                  <th>STUN服务提供商</th>
                  <th>IP</th>
                  <th>NAT类型</th>
                </tr>
              </thead>
              <tbody>
                <template is="replace-temp">
                  <x-fill :value="stunResults" name="stunResultRow"></x-fill>
                </template>
              </tbody>
            </table>
          </x-if>
          <x-else>
            <x-fill :value="errorReason">
              <p style="color: red;" :text="$data"></p>
            </x-fill>
          </x-else>
        </section>
        <section>
          <h2>NAT 类型说明</h2>
          <ul>
            <x-fill :value="natTypes">
              <li>
                <strong><a attr:href="$data.src" target="_blank">{{$data.name}}</a></strong>：
                {{$data.desc}}
              </li>
            </x-fill>
            <li>
              <strong>未知 NAT 类型</strong>：
              无法确定 NAT 类型。
            </li>
          </ul>
        </section>
        <section>
          <h2>API 获取 IP 信息</h2>
          <l-m src="./component/ip-info.html"></l-m>
          <ip-info></ip-info>
        </section>
      </main>
      <footer>
        <div>
          <l-m src="./component/shields-badge.html"></l-m>
          <shields-badge href="https://github.com/cyb233/ip-worker" path="github/stars/cyb233/ip-worker" query="maxAge=0" alt="GitHub Repo stars"></shields-badge>
        </div>
        Powered by <a href="https://workers.cloudflare.com/" target="_blank">Cloudflare Workers</a>
      </footer>

      <template name="stunResultRow">
        <tr>
          <td attr:title="$data.urls" class:hidden="$index > 0 && $host.stunResults[$index - 1].provider === $data.provider" attr:rowspan="$host.stunResults.filter(r => r.provider === $data.provider).length">{{$data.provider}}</td>
          <td>{{$data.ip}}</td>
          <td>{{$data.natType}}</td>
        </tr>
      </template>


      <script>
        export default {
          data: {
            stunServers: [
              // https://gist.github.com/mondain/b0ec1cf5f60ae726202e
              // https://github.com/pradt2/always-online-stun/blob/master/valid_hosts.txt
              { provider: 'Google', urls: 'stun:stun.l.google.com:19302' },
              { provider: 'Cloudflare', urls: 'stun:stun.cloudflare.com:3478' },
              { provider: 'XiaoMi', urls: 'stun:stun.miwifi.com:3478' },
              { provider: 'Bilibili', urls: 'stun:stun.chat.bilibili.com:3478' },
              { provider: 'Nextcloud', urls: 'stun:stun.nextcloud.com:3478' }
            ],
            natTypes: [
              // https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type
              { type: 'host', name: '全锥形 NAT (Full Cone NAT)', desc: '所有外部主机都能通过映射的端口访问内部主机。', src: 'https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#host' },
              { type: 'srflx', name: '受限锥形 NAT (Restricted Cone NAT)', desc: '外部主机只有在发送过数据给内部主机后，才能访问内部主机的端口。', src: 'https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#srflx' },
              { type: 'prflx', name: '端口受限 NAT (Port Restricted NAT)', desc: '外部主机只有在发送过数据给内部主机指定端口后，才能访问该端口。', src: 'https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#prflx' },
              { type: 'relay', name: '对称 NAT (Symmetric NAT)', desc: '不同外部地址映射不同端口，通常无法直接建立 P2P 连接，需要中继 (relay)。', src: 'https://developer.mozilla.org/zh-CN/docs/Web/API/RTCIceCandidate/type#relay' },
            ],
            stunResults: [],
            errorReason: [],
          },
          ready() {
            this.getAllStunIps();
          },
          proto: {
            async getAllStunIps() {
              return await Promise.all(this.stunServers.map(server => this.getIpFromStun(server)));
            },
            addErrorReason(reason) {
              if (!this.errorReason.includes(reason))
                this.errorReason.push(reason);
            },
            async getIpFromStun(serverConfig) {
              return new Promise(() => {
                const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
                if (!RTCPeerConnection) {
                  console.error('当前浏览器不支持 WebRTC');
                  this.addErrorReason('当前浏览器不支持 WebRTC');
                  return;
                }

                const ips = [];
                const pc = new RTCPeerConnection({ iceServers: [serverConfig] });
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));

                pc.onicecandidate = (event) => {
                  if (!event || !event.candidate) {
                    pc.close();
                    if (ips.length) {
                      for (const ip of ips) {
                        this.stunResults.push({
                          provider: serverConfig.provider,
                          urls: serverConfig.urls,
                          ip: ip.ip,
                          natType: ip.natType
                        });
                      }
                    } else {
                      this.addErrorReason('无法获取IP，请检查WebRTC是否被禁用，或网络是否连通');
                    }
                    return;
                  }

                  console.debug(event.candidate);
                  const ip = (event.candidate.address || '').replace(/^\[|\]$/g, '');
                  if (ip) {
                    const natType = this.inferNatType(event.candidate.type);
                    ips.push({ ip, natType });
                  }
                }
              })
            },
            inferNatType(candidateType) {
              return this.natTypes.find(type => type.type === candidateType)?.name || '未知 NAT 类型';
            }
          }
        }
      </script>
    </template>
  </o-app>
</body>

</html>
